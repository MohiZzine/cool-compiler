
package irgen

import (
	"fmt"
	"strconv"

	"github.com/llir/llvm/ir"
	"github.com/llir/llvm/ir/constant"
	"github.com/llir/llvm/ir/enum"
	"github.com/llir/llvm/ir/types"
	"github.com/llir/llvm/ir/value"

	"cool-compiler/ast"
)

// IRGenerator holds the LLVM module and maps for class types, vtable types, global vtables,
// method prototypes, type tags, and method orders.
type IRGenerator struct {
	mod           *ir.Module
	classTypes    map[string]*types.StructType // maps class names to class struct types
	vtableTypes   map[string]*types.StructType   // maps class names to vtable struct types
	vtableMap     map[string]value.Value         // maps class names to global vtable variables
	methodFuncs   map[string]*ir.Func            // maps method prototypes (e.g. "Animal_greet") to functions
	Program       *ast.Program                   // stored AST
	methodOrders  map[string][]string            // method order for each class
	typeTags      map[string]int                 // type tag for each class
	strCount      int                            // counter for unique string constants
}

// NewIRGenerator creates a new IR generator with an empty LLVM module.
func NewIRGenerator() *IRGenerator {
	return &IRGenerator{
		mod:          ir.NewModule(),
		classTypes:   make(map[string]*types.StructType),
		vtableTypes:  make(map[string]*types.StructType),
		vtableMap:    make(map[string]value.Value),
		methodFuncs:  make(map[string]*ir.Func),
		methodOrders: make(map[string][]string),
		typeTags:     make(map[string]int),
		strCount:     0,
	}
}

// getParentName returns the declared parent of the given class (or "" if none).
func (gen *IRGenerator) getParentName(className string) string {
	if gen.Program == nil {
		return ""
	}
	for _, cls := range gen.Program.Classes {
		if cls.Name == className {
			return cls.Parent
		}
	}
	return ""
}

// getVtable returns the global vtable for the given class name.
func (gen *IRGenerator) getVtable(className string) (value.Value, error) {
	if vt, ok := gen.vtableMap[className]; ok {
		return vt, nil
	}
	return nil, fmt.Errorf("vtable not found for class %s", className)
}

// BuildMethodOrders computes a method order for each class (inherit parent's order, then add declared methods).
func (gen *IRGenerator) BuildMethodOrders(program *ast.Program) {
	for _, class := range program.Classes {
		var order []string
		if parent := gen.getParentName(class.Name); parent != "" {
			if pOrder, ok := gen.methodOrders[parent]; ok {
				order = make([]string, len(pOrder))
				copy(order, pOrder)
			}
		}
		for _, method := range class.Methods {
			found := false
			for i, mName := range order {
				if mName == method.Name {
					order[i] = method.Name
					found = true
					break
				}
			}
			if !found {
				order = append(order, method.Name)
			}
		}
		gen.methodOrders[class.Name] = order
	}
}

// BuildClassTypes creates LLVM struct types for all classes.
// Layout: { i32 type tag, vtable pointer, <attributes...> }.
func (gen *IRGenerator) BuildClassTypes(program *ast.Program) error {
	// Assign type tags.
	tag := 1
	for _, class := range program.Classes {
		gen.typeTags[class.Name] = tag
		tag++
	}
	for _, class := range program.Classes {
		vtableType, ok := gen.vtableTypes[class.Name]
		if !ok {
			// If no vtable type exists, create an empty one.
			vtableType = types.NewStruct()
			vtableType.SetName(class.Name + "_vtable_type")
			gen.vtableTypes[class.Name] = vtableType
		}
		// First field is the type tag (i32), second field is the vtable pointer.
		fields := []types.Type{
			types.I32,                    // type tag field
			types.NewPointer(vtableType), // vtable pointer field
		}
		// Append attribute types.
		for _, attr := range class.Attributes {
			fields = append(fields, gen.mapCoolType(attr.Type))
		}
		classType := types.NewStruct(fields...)
		classType.SetName(class.Name)
		gen.classTypes[class.Name] = classType
	}
	return nil
}

// mapCoolType maps a COOL type to an LLVM type.
func (gen *IRGenerator) mapCoolType(coolType string) types.Type {
	switch coolType {
	case "Int":
		return types.I32
	case "Bool":
		return types.I1
	case "String":
		return types.NewPointer(types.I8)
	default:
		if ct, ok := gen.classTypes[coolType]; ok {
			return types.NewPointer(ct)
		}
		return types.NewPointer(types.I32)
	}
}

// PrototypeMethods creates function prototypes for all methods.
// For methods with no parameters, we force the signature to be exactly i8* (i8*).
// For methods with parameters, you could extend this approach accordingly.
func (gen *IRGenerator) PrototypeMethods(program *ast.Program) error {
	// Build a common function type for methods with no parameters:
	commonFuncType := types.NewFunc(types.NewPointer(types.I8), []types.Type{types.NewPointer(types.I8)}...)
	commonFuncType.Variadic = false

	for _, class := range program.Classes {
		// For each method in the class:
		for _, method := range class.Methods {
			var funcType *types.FuncType
			// If there are no formal parameters, use the common function type.
			if len(method.Parameters) == 0 {
				funcType = commonFuncType
			} else {
				// Otherwise, flatten each parameter to i8*.
				thisType := types.NewPointer(types.I8)
				retType := types.NewPointer(types.I8)
				// Always start with self.
				paramTypes := []types.Type{thisType}
				for range method.Parameters {
					paramTypes = append(paramTypes, types.NewPointer(types.I8))
				}
				funcType = types.NewFunc(retType, paramTypes...)
				funcType.Variadic = false
			}
			funcName := class.Name + "_" + method.Name
			f := gen.mod.NewFunc(funcName, funcType)
			// Set parameters: if method has no parameters, we only have self.
			selfParam := ir.NewParam("self", types.NewPointer(types.I8))
			f.Params = append(f.Params, selfParam)
			if len(method.Parameters) > 0 {
				for _, param := range method.Parameters {
					p := ir.NewParam(param.Name, types.NewPointer(types.I8))
					f.Params = append(f.Params, p)
				}
			}
			gen.methodFuncs[funcName] = f
			fmt.Printf("[DEBUG] Prototyped function (flattened): %s\n", funcName)
		}
	}
	return nil
}

// BuildVTableTypes creates a vtable struct type for each class.
// It uses a common function pointer type i8* (i8*)* to represent all method pointers.
func (gen *IRGenerator) BuildVTableTypes(program *ast.Program) error {
	// Build the method order for each class (including inherited methods).
	gen.BuildMethodOrders(program)
	// Define the common function type: i8* (i8*)*
	commonFuncType := types.NewFunc(types.NewPointer(types.I8), []types.Type{types.NewPointer(types.I8)}...)
	commonFuncType.Variadic = false
	commonFuncPtrType := types.NewPointer(commonFuncType)
	for _, class := range program.Classes {
		order := gen.methodOrders[class.Name]
		var fieldTypes []types.Type
		for _, mName := range order {
			funcName := class.Name + "_" + mName
			f, ok := gen.methodFuncs[funcName]
			if !ok {
				// Fallback: if not overridden, use parent's prototype.
				parentName := gen.getParentName(class.Name)
				if parentName == "" {
					return fmt.Errorf("vtable: method %s not found for class %s and no parent available", mName, class.Name)
				}
				parentFuncName := parentName + "_" + mName
				pf, ok := gen.methodFuncs[parentFuncName]
				if !ok {
					return fmt.Errorf("vtable: inherited method %s not found in parent %s", mName, parentName)
				}
				f = pf
			}
			// Bitcast the method pointer to our common function pointer type.
			fp := constant.NewBitCast(f, commonFuncPtrType)
			fieldTypes = append(fieldTypes, fp.Type())
		}
		vtableType := types.NewStruct(fieldTypes...)
		vtableType.SetName(class.Name + "_vtable_type")
		gen.vtableTypes[class.Name] = vtableType
	}
	return nil
}

// BuildVTables creates global vtable variables for each class.
func (gen *IRGenerator) BuildVTables(program *ast.Program) error {
	if err := gen.BuildVTableTypes(program); err != nil {
		return err
	}
	// Define the common function type: i8* (i8*)*
	commonFuncType := types.NewFunc(types.NewPointer(types.I8), []types.Type{types.NewPointer(types.I8)}...)
	commonFuncType.Variadic = false
	commonFuncPtrType := types.NewPointer(commonFuncType)
	for _, class := range program.Classes {
		order := gen.methodOrders[class.Name]
		_, ok := gen.vtableTypes[class.Name]
		if !ok {
			return fmt.Errorf("vtable type for class %s not found", class.Name)
		}
		var elems []constant.Constant
		for _, mName := range order {
			funcName := class.Name + "_" + mName
			if f, ok := gen.methodFuncs[funcName]; ok {
				fp := constant.NewBitCast(f, commonFuncPtrType)
				elems = append(elems, fp)
			} else {
				// Fallback: inherit parent's prototype.
				parentName := gen.getParentName(class.Name)
				if parentName == "" {
					return fmt.Errorf("method %s not found for class %s and no parent", mName, class.Name)
				}
				parentFuncName := parentName + "_" + mName
				pf, ok := gen.methodFuncs[parentFuncName]
				if !ok {
					return fmt.Errorf("inherited method %s not found in parent %s", mName, parentName)
				}
				fp := constant.NewBitCast(pf, commonFuncPtrType)
				elems = append(elems, fp)
			}
		}
		// Create an array type for the vtable entries.
		arrType := types.NewArray(uint64(len(elems)), commonFuncPtrType)
		vtableConst := constant.NewArray(arrType, elems...)
		globalVtable := gen.mod.NewGlobalDef("vtable."+class.Name, vtableConst)
		gen.vtableMap[class.Name] = globalVtable
	}
	return nil
}

// GenerateMethodBodies generates function bodies for all methods.
func (gen *IRGenerator) GenerateMethodBodies(program *ast.Program) error {
	for _, class := range program.Classes {
		for _, method := range class.Methods {
			funcName := class.Name + "_" + method.Name
			f, ok := gen.methodFuncs[funcName]
			if !ok {
				return fmt.Errorf("method prototype %s not found", funcName)
			}
			entry := f.NewBlock("entry")
			env := make(map[string]value.Value)
			// Allocate self; note that self is of type i8*, so we use that type.
			selfAlloca := entry.NewAlloca(f.Params[0].Type())
			entry.NewStore(f.Params[0], selfAlloca)
			loadedSelf := entry.NewLoad(f.Params[0].Type().(*types.PointerType).ElemType, selfAlloca)
			env["this"] = loadedSelf
			for _, param := range f.Params[1:] {
				alloca := entry.NewAlloca(param.Type())
				entry.NewStore(param, alloca)
				env[param.Name()] = alloca
			}
			val, err := gen.codegenExpr(method.Body, entry, env)
			if err != nil {
				return fmt.Errorf("method %s: %v", funcName, err)
			}
			entry.NewRet(val)
			fmt.Printf("[DEBUG] Generated body for function: %s\n", funcName)
		}
	}
	return nil
}

// codegenExpr recursively generates LLVM IR for a COOL expression.
func (gen *IRGenerator) codegenExpr(expr ast.Expr, block *ir.Block, env map[string]value.Value) (value.Value, error) {
	if expr == nil {
		return nil, fmt.Errorf("nil expression")
	}
	switch e := expr.(type) {
	case *ast.IntExpr:
		return constant.NewInt(types.I32, int64(e.Value)), nil
	case *ast.StringExpr:
		gen.strCount++
		strName := fmt.Sprintf(".str.%d", gen.strCount)
		strConst := constant.NewCharArrayFromString(e.Value + "\x00")
		strGlobal := gen.mod.NewGlobalDef(strName, strConst)
		strGlobal.Immutable = true
		zero := constant.NewInt(types.I32, 0)
		return block.NewGetElementPtr(strGlobal.ContentType, strGlobal, zero, zero), nil
	case *ast.BoolExpr:
		return constant.NewInt(types.I1, map[bool]int64{false: 0, true: 1}[e.Value]), nil
	case *ast.VarExpr:
		ptr, ok := env[e.Name]
		if !ok {
			return nil, fmt.Errorf("undefined variable: %s", e.Name)
		}
		return block.NewLoad(ptr.Type().(*types.PointerType).ElemType, ptr), nil
	case *ast.AssignExpr:
		ptr, ok := env[e.Name]
		if !ok {
			return nil, fmt.Errorf("undefined variable in assignment: %s", e.Name)
		}
		val, err := gen.codegenExpr(e.Value, block, env)
		if err != nil {
			return nil, err
		}
		block.NewStore(val, ptr)
		return val, nil
	case *ast.BinaryExpr:
		left, err := gen.codegenExpr(e.Left, block, env)
		if err != nil {
			return nil, err
		}
		right, err := gen.codegenExpr(e.Right, block, env)
		if err != nil {
			return nil, err
		}
		switch e.Operator {
		case "+":
			return block.NewAdd(left, right), nil
		case "-":
			return block.NewSub(left, right), nil
		case "*":
			return block.NewMul(left, right), nil
		case "/":
			return block.NewSDiv(left, right), nil
		case "<":
			cmp := block.NewICmp(enum.IPredSLT, left, right)
			return block.NewZExt(cmp, types.I32), nil
		case "<=":
			cmp := block.NewICmp(enum.IPredSLE, left, right)
			return block.NewZExt(cmp, types.I32), nil
		case "=":
			cmp := block.NewICmp(enum.IPredEQ, left, right)
			return block.NewZExt(cmp, types.I32), nil
		default:
			return nil, fmt.Errorf("unsupported binary operator: %s", e.Operator)
		}
	case *ast.UnaryExpr:
		operand, err := gen.codegenExpr(e.Operand, block, env)
		if err != nil {
			return nil, err
		}
		switch e.Operator {
		case "~":
			return block.NewSub(constant.NewInt(types.I32, 0), operand), nil
		case "not":
			cmp := block.NewICmp(enum.IPredEQ, operand, constant.NewInt(types.I1, 0))
			return block.NewZExt(cmp, types.I32), nil
		case "isvoid":
			ptr, ok := operand.Type().(*types.PointerType)
			if !ok {
				return nil, fmt.Errorf("isvoid: operand type is not a pointer")
			}
			cmp := block.NewICmp(enum.IPredEQ, operand, constant.NewNull(ptr))
			return block.NewZExt(cmp, types.I32), nil
		default:
			return nil, fmt.Errorf("unsupported unary operator: %s", e.Operator)
		}
	case *ast.BlockExpr:
		var last value.Value
		for _, expr := range e.Expressions {
			val, err := gen.codegenExpr(expr, block, env)
			if err != nil {
				return nil, err
			}
			last = val
		}
		return last, nil
	case *ast.DispatchExpr:
		return gen.codegenDispatch(e.Caller, e.Method, e.Arguments, block, env)
	case *ast.IfExpr:
		condVal, err := gen.codegenExpr(e.Condition, block, env)
		if err != nil {
			return nil, err
		}
		thenBlock := block.Parent.NewBlock("if.then")
		elseBlock := block.Parent.NewBlock("if.else")
		mergeBlock := block.Parent.NewBlock("if.merge")
		condBool := block.NewICmp(enum.IPredNE, condVal, constant.NewInt(types.I32, 0))
		block.NewCondBr(condBool, thenBlock, elseBlock)
		thenVal, err := gen.codegenExpr(e.ThenBranch, thenBlock, copyEnv(env))
		if err != nil {
			return nil, err
		}
		thenBlock.NewBr(mergeBlock)
		elseVal, err := gen.codegenExpr(e.ElseBranch, elseBlock, copyEnv(env))
		if err != nil {
			return nil, err
		}
		elseBlock.NewBr(mergeBlock)
		phi := &ir.InstPhi{
			Typ: thenVal.Type(),
			Incs: []*ir.Incoming{
				{X: thenVal, Pred: thenBlock},
				{X: elseVal, Pred: elseBlock},
			},
		}
		mergeBlock.Insts = append(mergeBlock.Insts, phi)
		return phi, nil
	case *ast.WhileExpr:
		condBlock := block.Parent.NewBlock("while.cond")
		bodyBlock := block.Parent.NewBlock("while.body")
		afterBlock := block.Parent.NewBlock("while.after")
		block.NewBr(condBlock)
		condVal, err := gen.codegenExpr(e.Condition, condBlock, copyEnv(env))
		if err != nil {
			return nil, err
		}
		condBool := condBlock.NewICmp(enum.IPredNE, condVal, constant.NewInt(types.I32, 0))
		condBlock.NewCondBr(condBool, bodyBlock, afterBlock)
		_, err = gen.codegenExpr(e.Body, bodyBlock, copyEnv(env))
		if err != nil {
			return nil, err
		}
		bodyBlock.NewBr(condBlock)
		return constant.NewInt(types.I32, 0), nil
	case *ast.LetExpr:
		newEnv := copyEnv(env)
		entryBlock := block.Parent.Blocks[0]
		for _, binding := range e.Variables {
			ty := gen.mapCoolType(binding.Type)
			alloca := entryBlock.NewAlloca(ty)
			var initVal value.Value
			if binding.InitValue != nil {
				v, err := gen.codegenExpr(binding.InitValue, block, newEnv)
				if err != nil {
					return nil, err
				}
				initVal = v
			} else {
				switch binding.Type {
				case "Int":
					initVal = constant.NewInt(types.I32, 0)
				case "Bool":
					initVal = constant.NewInt(types.I1, 0)
				case "String":
					initVal = constant.NewNull(types.NewPointer(types.I8))
				default:
					t := gen.mapCoolType(binding.Type)
					ptr, ok := t.(*types.PointerType)
					if !ok {
						return nil, fmt.Errorf("let binding %s: type %s is not a pointer type", binding.Name, binding.Type)
					}
					initVal = constant.NewNull(ptr)
				}
			}
			block.NewStore(initVal, alloca)
			newEnv[binding.Name] = alloca
		}
		return gen.codegenExpr(e.Body, block, newEnv)
	case *ast.StaticDispatchExpr:
		callerVal, err := gen.codegenExpr(e.Caller, block, env)
		if err != nil {
			return nil, err
		}
		funcName := e.Type + "_" + e.Method
		var callee *ir.Func
		for _, f := range gen.mod.Funcs {
			if f.Name() == funcName {
				callee = f
				break
			}
		}
		if callee == nil {
			return nil, fmt.Errorf("static dispatch: function %s not found", funcName)
		}
		args := []value.Value{callerVal}
		for _, arg := range e.Arguments {
			a, err := gen.codegenExpr(arg, block, env)
			if err != nil {
				return nil, err
			}
			args = append(args, a)
		}
		return block.NewCall(callee, args...), nil
	case *ast.NewExpr:
		return gen.codegenNewExpr(e, block, env)
	case *ast.CaseExpr:
		discVal, err := gen.codegenExpr(e.Expr, block, env)
		if err != nil {
			return nil, err
		}
		ttPtr := block.NewGetElementPtr(gen.classTypesFromValue(discVal), discVal,
			constant.NewInt(types.I32, 0), constant.NewInt(types.I32, 0))
		ptrType3, ok := ttPtr.Type().(*types.PointerType)
		if !ok {
			return nil, fmt.Errorf("case: type error")
		}
		discTag := block.NewLoad(ptrType3.ElemType, ttPtr)
		mergeBlock := block.Parent.NewBlock("case.merge")
		phi := &ir.InstPhi{
			Typ:  types.I32,
			Incs: []*ir.Incoming{},
		}
		mergeBlock.Insts = append(mergeBlock.Insts, phi)
		for i, branch := range e.Cases {
			branchBlock := block.Parent.NewBlock("case.branch." + strconv.Itoa(i))
			branchTag, ok := gen.typeTags[branch.Type]
			if !ok {
				return nil, fmt.Errorf("case: unknown branch type %s", branch.Type)
			}
			cond := block.NewICmp(enum.IPredEQ, discTag, constant.NewInt(types.I32, int64(branchTag)))
			nextBlock := block.Parent.NewBlock("case.next." + strconv.Itoa(i))
			block.NewCondBr(cond, branchBlock, nextBlock)
			val, err := gen.codegenExpr(branch.Body, branchBlock, copyEnv(env))
			if err != nil {
				return nil, err
			}
			branchBlock.NewBr(mergeBlock)
			phi.Incs = append(phi.Incs, &ir.Incoming{
				X:    val,
				Pred: branchBlock,
			})
			block = nextBlock
		}
		errMsg := constant.NewCharArrayFromString("No matching branch in case")
		errStrGlobal := gen.mod.NewGlobalDef(".str.error", errMsg)
		errStrPtr := block.NewGetElementPtr(errStrGlobal.ContentType, errStrGlobal,
			constant.NewInt(types.I32, 0), constant.NewInt(types.I32, 0))
		errFunc := gen.runtimeErrorFunc()
		block.NewCall(errFunc, errStrPtr)
		block.NewBr(mergeBlock)
		return phi, nil
	default:
		return nil, fmt.Errorf("unsupported expression type: %T", expr)
	}
}

// codegenDispatch generates LLVM IR for a method call.
func (gen *IRGenerator) codegenDispatch(callerExpr ast.Expr, methodName string, args []ast.Expr, block *ir.Block, env map[string]value.Value) (value.Value, error) {
	callerVal, err := gen.codegenExpr(callerExpr, block, env)
	if err != nil {
		return nil, err
	}
	// Load vtable pointer from the object's first field.
	vtablePtrPtr := block.NewGetElementPtr(gen.classTypesFromValue(callerVal), callerVal,
		constant.NewInt(types.I32, 0), constant.NewInt(types.I32, 0))
	vtablePtr := block.NewLoad(vtablePtrPtr.Type().(*types.PointerType).ElemType, vtablePtrPtr)
	// Determine method index.
	classType := gen.classTypesFromValue(callerVal)
	if classType == nil {
		return nil, fmt.Errorf("could not determine class type from caller")
	}
	_, ok := gen.methodOrders[classType.Name()]
	if !ok {
		return nil, fmt.Errorf("no method order for class %s", classType.Name())
	}
	methodIndex, err := gen.getMethodIndexForCaller(methodName, callerVal, "")
	if err != nil {
		return nil, err
	}
	// Retrieve vtable type.
	vtableType := gen.vtableTypes[classType.Name()]
	// Cast vtable pointer to pointer to vtable type.
	castedVtable := block.NewBitCast(vtablePtr, types.NewPointer(vtableType))
	// Get the method pointer field.
	methodPtrPtr := block.NewGetElementPtr(vtableType, castedVtable,
		constant.NewInt(types.I32, 0), constant.NewInt(types.I32, int64(methodIndex)))
	methodPtr := block.NewLoad(methodPtrPtr.Type().(*types.PointerType).ElemType, methodPtrPtr)
	// Prepare call arguments.
	// NOTE: Since our method signatures expect i8*, ensure the caller value is used as-is.
	callArgs := []value.Value{callerVal}
	for _, arg := range args {
		a, err := gen.codegenExpr(arg, block, env)
		if err != nil {
			return nil, err
		}
		callArgs = append(callArgs, a)
	}
	return block.NewCall(methodPtr, callArgs...), nil
}

// codegenNewExpr generates IR for a NewExpr node.
func (gen *IRGenerator) codegenNewExpr(e *ast.NewExpr, block *ir.Block, env map[string]value.Value) (value.Value, error) {
	classType, ok := gen.classTypes[e.Type]
	if !ok {
		return nil, fmt.Errorf("new: unknown type %s", e.Type)
	}
	var mallocFunc *ir.Func
	for _, f := range gen.mod.Funcs {
		if f.Name() == "malloc" {
			mallocFunc = f
			break
		}
	}
	if mallocFunc == nil {
		mallocFunc = gen.mod.NewFunc("malloc", types.NewPointer(types.I8), ir.NewParam("size", types.I64))
	}
	// Here, size is hardcoded to 64; ideally, compute the sizeof(classType).
	size := constant.NewInt(types.I64, 64)
	rawPtr := block.NewCall(mallocFunc, size)
	objPtr := block.NewBitCast(rawPtr, types.NewPointer(classType))
	
	// Store type tag in field 0.
	typeTag := constant.NewInt(types.I32, int64(gen.typeTags[e.Type]))
	ttPtr := block.NewGetElementPtr(classType, objPtr,
		constant.NewInt(types.I32, 0), // first index (object pointer level)
		constant.NewInt(types.I32, 0)) // field index 0 (type tag)
	block.NewStore(typeTag, ttPtr)
	
	// Retrieve the global vtable for the type.
	vtableGlobal, err := gen.getVtable(e.Type)
	if err != nil {
		return nil, fmt.Errorf("new: %v", err)
	}
	// Bitcast the global vtable to a pointer to the correct vtable type.
	vtablePtr := block.NewBitCast(vtableGlobal, types.NewPointer(gen.vtableTypes[e.Type]))
	vtPtr := block.NewGetElementPtr(classType, objPtr,
		constant.NewInt(types.I32, 0), // first index
		constant.NewInt(types.I32, 1)) // field index 1 (vtable pointer)
	block.NewStore(vtablePtr, vtPtr)
	
	return objPtr, nil
}

// copyEnv returns a shallow copy of the environment.
func copyEnv(env map[string]value.Value) map[string]value.Value {
	newEnv := make(map[string]value.Value)
	for k, v := range env {
		newEnv[k] = v
	}
	return newEnv
}

// classTypesFromValue returns the underlying struct type from a pointer value.
func (gen *IRGenerator) classTypesFromValue(val value.Value) *types.StructType {
	if pt, ok := val.Type().(*types.PointerType); ok {
		if st, ok := pt.ElemType.(*types.StructType); ok {
			return st
		}
	}
	return nil
}

// getMethodIndexForCaller returns the index of the given method in the callerâ€™s vtable.
func (gen *IRGenerator) getMethodIndexForCaller(methodName string, caller value.Value, overrideClass string) (int, error) {
	var className string
	if overrideClass != "" {
		className = overrideClass
	} else {
		ct := gen.classTypesFromValue(caller)
		if ct == nil {
			return 0, fmt.Errorf("could not determine class type from caller")
		}
		className = ct.Name()
	}
	order, ok := gen.methodOrders[className]
	if !ok {
		return 0, fmt.Errorf("no method order for class %s", className)
	}
	for i, m := range order {
		if m == methodName {
			return i, nil
		}
	}
	return 0, fmt.Errorf("method %s not found in vtable for class %s", methodName, className)
}

// runtimeErrorFunc returns the runtime error function.
func (gen *IRGenerator) runtimeErrorFunc() *ir.Func {
	name := "runtime_error"
	for _, f := range gen.mod.Funcs {
		if f.Name() == name {
			return f
		}
	}
	return gen.mod.NewFunc(name, types.Void, ir.NewParam("msg", types.NewPointer(types.I8)))
}

// codegenNewObject creates a new object of the given class.
func (gen *IRGenerator) codegenNewObject(className string, block *ir.Block) (value.Value, error) {
	classType, ok := gen.classTypes[className]
	if !ok {
		return nil, fmt.Errorf("new: unknown type %s", className)
	}
	var mallocFunc *ir.Func
	for _, f := range gen.mod.Funcs {
		if f.Name() == "malloc" {
			mallocFunc = f
			break
		}
	}
	if mallocFunc == nil {
		mallocFunc = gen.mod.NewFunc("malloc", types.NewPointer(types.I8), ir.NewParam("size", types.I64))
	}
	size := constant.NewInt(types.I64, 64)
	rawPtr := block.NewCall(mallocFunc, size)
	objPtr := block.NewBitCast(rawPtr, types.NewPointer(classType))
	typeTag := constant.NewInt(types.I32, int64(gen.typeTags[className]))
	ttPtr := block.NewGetElementPtr(classType, objPtr,
		constant.NewInt(types.I32, 0), constant.NewInt(types.I32, 0))
	block.NewStore(typeTag, ttPtr)
	vtableGlobal, err := gen.getVtable(className)
	if err != nil {
		return nil, fmt.Errorf("new: %v", err)
	}
	vtablePtr := block.NewBitCast(vtableGlobal, types.NewPointer(types.I8))
	vtPtr := block.NewGetElementPtr(classType, objPtr,
		constant.NewInt(types.I32, 0), constant.NewInt(types.I32, 1))
	block.NewStore(vtablePtr, vtPtr)
	return objPtr, nil
}

// GenerateModule runs all phases and returns the complete LLVM module.
func (gen *IRGenerator) GenerateModule(program *ast.Program) (*ir.Module, error) {
	gen.Program = program
	if err := gen.BuildClassTypes(program); err != nil {
		return nil, err
	}
	if err := gen.PrototypeMethods(program); err != nil {
		return nil, err
	}
	if err := gen.BuildVTables(program); err != nil {
		return nil, err
	}
	if err := gen.GenerateMethodBodies(program); err != nil {
		return nil, err
	}
	fmt.Println("[DEBUG] Vtable map keys:")
	for className := range gen.vtableMap {
		fmt.Printf(" - %s\n", className)
	}
	return gen.mod, nil
}
